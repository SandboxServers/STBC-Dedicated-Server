> [docs](../README.md) / [networking](README.md) / netimmerse-transport-deep-dive.md

# NetImmerse Transport Layer Deep Dive — Agent Analysis

> Generated by netimmerse-engine-dev agent, 2026-02-19.
> Source: `reference/decompiled/11_tgnetwork.c` (7,334 lines) and `reference/decompiled/12_data_serialization.c`.
> Ghidra was not reachable during this session — all findings derived from prior decompilation output.
> **Confidence annotations added by orchestrator where evidence contradicts conclusions.**

---

## 1. TGMessage Vtable — All Slots

From call patterns throughout the decompiled source:

| Slot | Offset | Evidence | Name |
|------|--------|----------|------|
| 0 | +0x00 | Called everywhere as `(*vtable[0])()`; result compared to 0x32 and to type constants | **GetType()** — returns u8 message type |
| 1 | +0x04 | Called as `(*vtable[4])(1)` to destroy messages | **scalar_deleting_destructor(flag)** |
| 2 | +0x08 | Called as `(*vtable[8])(buf_ptr, remaining_space)` in all three queue send loops | **WriteToBuffer(buf, maxSize)** — returns bytes written, 0 on failure |
| 3 | +0x0C | Called as `(*vtable[0xc])(other_msg)` in `FUN_006b6f30`, returns bool | **Supersedes(other) or IsExpired()** — used to discard stale unreliable messages when a newer reliable arrives |
| 4 | +0x10 | Called in `FUN_006b6ad0` line 4137 as `(*vtable[0x10])()`, non-zero → call `FUN_006b6f30` | **IsOrderedDelivery()** or **HasOrdering()** — triggers the unreliable-queue discard pass |
| 5 | +0x14 | Called everywhere as `(*vtable[0x14])()` to advance the buffer pointer after deserialization | **GetSize()** — returns serialized byte count for this message |
| 6 | +0x18 | Called as `(*vtable[0x18])()` when making per-peer copies | **Clone()** — `FUN_006b8610`, alloc 0x40 bytes + copy-construct |
| 7 | +0x1C | Called as `(*vtable[0x1c])(&count, maxSize)` in SendHelper | **FragmentMessage(&fragCount, maxPayload)** — `FUN_006b8720` |

There are no additional vtable slots beyond these 8. The vtable is 32 bytes total (8 × 4). **No virtual methods are involved in ACK matching or seq comparison.** HandleACK and HandleReliableReceived both use direct field reads (`piVar + 5` for seq, `+0xf` for is_fragmented, `+0x39` for frag_idx, `+0x40` for is_below_0x32), not virtual dispatch. This eliminates any vtable-based mismatch as a cause.

---

## 2. The Type 0x32 Boundary — Why It Exists and Whether It Causes Mismatches

The boundary partitions two completely separate reliable-delivery channels:

**Types 0x00–0x31** (< 0x32): Game message channel. Uses peer+0x24 (expected) and peer+0x26 (send counter). Dispatched through the queue at `TGWinsockNetwork+0x8C`.

**Types 0x32+** (>= 0x32): Session/lobby channel. Uses peer+0x28 (expected) and peer+0x2A (send counter). Dispatched through the queue at `TGWinsockNetwork+0x54`.

The partitioning is confirmed in:
- `FUN_006b5080` (SendHelper) lines 2715–2722: counter selection
- `FUN_006b6ad0` (QueueForDispatch) lines 4117–4124: expected-seq selection
- `FUN_006b6cc0` (ReassembleFragments) lines 4254–4258: queue selection

**Can this cause ACK mismatches?**

In principle, yes. The ACK contains `is_below_0x32` (bit 1 of the flags byte). HandleACK (line 3776) checks that the ACK's `is_below_0x32` matches `msg.GetType() < 0x32`. If the boundary determination differs at creation time vs ACK time, a mismatch would cause every ACK to fail to match.

However, from the decompilation: both `HandleReliableReceived` (FUN_006b61e0 line 3464) and `HandleACK` (FUN_006b64d0 line 3777) call `GetType()` on the same message objects (sender and receiver both use the TGDataMessage vtable). Fragments preserve their original GetType() via Clone(), which copies the vtable pointer. So `GetType()` returns the same value throughout the message lifetime. **The 0x32 boundary does not cause a mismatch in the fragmented message case**, unless the fragmented message is exactly type 0x32 — which is a degenerate edge case.

---

## 3. ACK Serialization Asymmetry — The Deserialization of is_below_0x32

**Serialization** (FUN_006bd190, TGHeaderMessage::WriteToBuffer):
```c
uVar1 = (*(code *)**this)();      // GetType() → 0x01
*param_1 = uVar1;                  // byte[0] = type
*(u16*)(param_1 + 1) = *(u16*)(this + 0x14);  // bytes[1,2] = seq
bVar4 = (*(char*)(this + 0x3c) != 0);          // bit0 = is_fragmented
if (*(char*)(this + 0x40) != 0) bVar4 |= 2;   // bit1 = is_below_0x32
param_1[3] = bVar4;                             // byte[3] = flags
if (*(char*)(this + 0x3c)) {
    param_1[4] = *(u8*)(this + 0x39);          // byte[4] = frag_idx
    return 5;
}
return 4;
```

**Deserialization** (factory at LAB_006bd1f0): Ghidra did not identify this as a named function — it's at address 0x006bd1f0 in the gap between FUN_006bd190 (0x006bd190) and FUN_006bd250 (0x006bd250). The gap is 0xC0 bytes. The factory was registered as `&LAB_006bd1f0`, a raw label at that address.

The agent inferred what it does from the pattern of the type-0 factory (FUN_006bc6a0):

```c
// Type 0 factory pattern (FUN_006bc6a0):
bVar2 = (byte)(uVar1 >> 8);                     // flags byte
*(byte*)(puVar4 + 0x3a) = bVar2 >> 7;           // is_reliable from bit 7
*(byte*)(puVar4 + 0x3b) = bVar2 >> 6 & 1;       // is_ordered from bit 6
```

For the ACK factory, the analogous reads from the wire would be:
- byte[1,2] → seq → msg+0x14
- byte[3] bit0 → is_fragmented → msg+0x3c
- byte[3] bit1 → is_below_0x32 → msg+0x40
- byte[4] (if fragmented) → frag_idx → msg+0x39

**The critical question**: does the ACK factory correctly set `msg+0x40` (is_below_0x32) from the wire?

Looking at the TGHeaderMessage constructor (FUN_006bd120): it sets `*(u8*)(param + 0x10) = 1` which is byte offset `0x10 * 4 = 0x40` → **is_below_0x32 defaults to 1 in every freshly-constructed TGHeaderMessage**. If the factory allocates a TGHeaderMessage via the constructor and then reads the flags byte from wire, it would overwrite this default. But if it fails to read the flags byte, the default of 1 persists.

> **ORCHESTRATOR NOTE**: The agent could not actually read the factory function at 0x006bd1f0 (Ghidra was not reachable). This is inference, not verified. The factory deserialization path remains an open question and is exactly what our [ACK-HOOK] diagnostic will capture at runtime.

---

## 4. Fragment Message Type Inheritance — Does Clone() Preserve GetType()?

**Yes, unambiguously.** `FUN_006b8720` (FragmentMessage) at line 5391:
```c
piVar6 = (int *)(**(code **)(*this + 0x18))();  // vtable[6] = Clone()
```

And `Clone()` is `FUN_006b8610` → `FUN_006b8550` (CopyConstructor). Line 5207:
```c
*(undefined ***)this = &PTR_LAB_008958d0;  // copies the SAME vtable
```

The copy constructor copies the vtable pointer from the source, preserving it. So fragments have the **identical vtable** as the original message, and `GetType()` returns the identical type.

**No mismatch here.**

---

## 5. The `is_ordered` Flag (+0x3B) and Fragment Queue Ordering

From `SendHelper` (FUN_006b5080), lines 2737–2764:

```c
if (*(char*)(iVar1 + 0x3b) == 0) {   // is_ordered == 0
    // Append to TAIL of first-send queue
    *(int**)(param_2 + 0x68) = piVar3;   // tail = new node
    *(int**)(param_2 + 0x64) = piVar3;   // (when empty: head = new node too)
} else {                                   // is_ordered == 1
    // Insert at HEAD of first-send queue
    piVar3[1] = *(int*)(param_2 + 0x64);  // new.next = old_head
    *(int**)(param_2 + 0x64) = piVar3;    // head = new
}
```

Since Clone() preserves `is_ordered`, if the original message has `is_ordered = 1`, ALL fragments are inserted at the HEAD in reverse order. Fragment 0 is processed first in the loop, inserted at head → [0]. Fragment 1 inserted at head → [1, 0]. Fragment 2 at head → [2, 1, 0]. **They're transmitted in order 2, 1, 0 — reversed.**

At the receiver, the reassembly in `FUN_006b6cc0` uses the `frag_idx` field (not arrival order) to index a 256-element array, so reassembly is correct regardless of arrival order. **This does not cause the ACK bug.**

The sequence counter check in `QueueForDispatch` (FUN_006b6ad0 line 4125) checks each fragment individually against `peer+0x24` (expected seq). All three fragments have the **same seq**. The check is:

```c
iVar5 = incoming_seq - expected_seq;
if ((-0x4001 < iVar5) && (iVar5 < 0 || 0x3fff < iVar5)) {
    destroy and return;  // out-of-window, no ACK
}
```

If `incoming_seq == expected_seq`, iVar5 = 0, which passes the check. After the first fragment is dispatched and the expected counter advances to seq+1, the second and third fragments with the same seq arrive with `incoming_seq - expected_seq = -1`. Since -1 is between -0x4001 and 0, this PASSES the check too. So all three fragments get ACKed regardless of arrival order. **No blocking here.**

---

## 6. Peer Sequence Counter — Receive Side for Fragments

From `DispatchReceivedMessages` (FUN_006b5f70), line 3626:
```c
if (*(char*)((int)piVar2 + 0x3a) != 0) {  // is_reliable
    *(short*)(iVar1 + 0x24) = (short)piVar2[5] + 1;  // expected_seq = fragment.seq + 1
}
```

This sets `expected_seq = seq + 1` for each dispatched reliable message. All three fragments have `seq = 0x0200`. So:

1. Fragment first dispatched: `expected_seq = 0x0200 + 1 = 0x0201`
2. Fragment second dispatched: `expected_seq = 0x0200 + 1 = 0x0201` (same, no change)
3. Fragment third dispatched: `expected_seq = 0x0200 + 1 = 0x0201`

The expected counter ends up at 0x0201 after all three. The ACK matching in HandleACK uses the client's **retransmit queue**, not the receive-side counter.

**No counter mismatch can cause the client to reject its own ACKs.**

---

## 7. Retransmit Queue Ordering — Partial ACK Matching

HandleACK returns after removing ONE entry. For a 3-fragment message, three separate ACK messages must arrive to clear all three retransmit entries.

The retransmit queue is a linked list. HandleACK uses index-based traversal with a cursor (`peer+0x8C`, `peer+0x90`). When an entry is removed, the cursor is updated correctly. **No structural issue with partial removal.**

---

## 8. TGWinsockNetwork::Update — Processing Order

From `FUN_006b4560`, lines 2184–2186:
```c
FUN_006b55b0(param_1);   // 1. SendOutgoingPackets (ACKs + retransmit + first-send)
FUN_006b5c90(param_1);   // 2. ProcessIncomingMessages (receive + ACK creation)
FUN_006b5f70(param_1);   // 3. DispatchReceivedMessages (type dispatch, HandleACK)
```

One tick of latency between receiving fragments and sending ACKs. Normal.

---

## 9. Hidden Peer State Between +0x30 and +0x64

From the peer constructor `FUN_006c08d0`:

| Offset | Init Value | Notes |
|--------|-----------|-------|
| +0x2C | DAT_0099c6bc | last_activity_time (current time float) |
| +0x30 | DAT_0099c6bc | last_connect_time |
| +0x34 through +0x60 | 0 | All zeros, no special semantics in ACK path |
| +0x64 | 0 | first-send queue head |

**No hidden state** that could affect ACK processing.

---

## 10. Backoff Mode (+0x2C) for Fragmented Messages

From `FUN_006b8670` (SetRetransmitCount):
- Mode 0 = fixed interval
- Mode 1 = linear backoff
- Mode 2 = exponential backoff (clamped to +0x34 max)

From TGMessage constructor: **backoff_mode = 1 (linear backoff)** for regular messages (including fragments via Clone).
From TGHeaderMessage constructor: **backoff_mode = 0 (fixed interval)** for ACKs.

Not the cause — fragments retransmit on their own timer.

---

## Agent's Root Cause Hypothesis — ACK Retransmit Count Exhaustion

> **ORCHESTRATOR NOTE — LOW CONFIDENCE**: This hypothesis contradicts the observable evidence. From the bug doc: "Both the stock dedicated server and our reimplementation produce **identical ACK bytes** and identical endless retransmit behavior." The ACKs are on the wire — the server IS sending them. The stock dedi sends plenty of StateUpdate traffic so the "pass 2 never fires" theory doesn't apply. This is a **client-side matching bug**, not a server-side send bug. The hypothesis below is included for completeness but should be treated as unverified.

The agent hypothesized that `SendOutgoingPackets` (FUN_006b55b0) has a `retransmit_count < 3` limit in the ACK-outbox send pass. After count reaches 3, ACK entries exit the primary send pass and only appear in pass 2 (conditional on prior data traffic). The dedup function refreshes timestamps but not retransmit_count, so entries stay stranded.

---

## Remaining Open Questions (for runtime diagnostics)

1. **ACK factory deserialization at 0x006bd1f0** — agent could not read this function. Does it correctly populate `is_below_0x32` at +0x40? Our `[ACK-HOOK]` will capture actual field values.

2. **Field-level mismatch** — our hooks log both ACK fields and retransmit queue entries side by side. Any delta reveals the matching bug.

3. **Whether HandleACK is even called** — if ACK dispatch somehow skips fragment ACKs, our hook call count will show it.
